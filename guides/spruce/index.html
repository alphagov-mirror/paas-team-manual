<!doctype html>
<html lang="en" class="no-js">
  <head>
    <meta content="IE=edge" http-equiv="X-UA-Compatible">
    <meta charset="utf-8">
    <meta content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" name="viewport">

    <!-- Use title if it's in the page YAML frontmatter -->
    <title>GOV.UK Documentation</title>

    <!--[if gt IE 8]><!--><link href="../../stylesheets/screen.css" rel="stylesheet" media="screen" /><!--<![endif]-->
    <!--[if lte IE 8]><link href="../../stylesheets/screen-old-ie.css" rel="stylesheet" media="screen" /><![endif]-->

    <link rel="canonical" href="https://alphagov.github.io/paas-team-manual/guides/spruce/">


    <link href="../../stylesheets/print.css" rel="stylesheet" media="print" />
    <script src="../../javascripts/application.js"></script>
  </head>

  <body>
    <div class="app-pane">
      <div class="app-pane__header toc-open-disabled">
        <a href="#content" class="skip-link">Skip to main content</a>

        <header class="header header--full-width">
  <div class="header__container">
    <div class="header__brand">
        <a href="https://alphagov.github.io/paas-team-manual">
        <span class="header__title">
          PaaS Team Manual
            <span class="phase-banner">Internal</span>
        </span>
        </a>
    </div>

  </div>
</header>

      </div>

      <div id="toc-heading" class="toc-show fixedsticky">
        <a href="#toc" class="toc-show__label js-toc-show" aria-controls="toc">
          Table of contents <span class="toc-show__icon"></span>
        </a>
      </div>

      <div class="app-pane__body" data-module="in-page-navigation">
        <div class="app-pane__toc">
          <div class="toc" data-module="table-of-contents">
            <a href="#" class="toc__close js-toc-close" aria-controls="toc" aria-label="Hide table of contents"></a>
            <nav id="toc" class="js-toc-list toc__list" aria-labelledby="toc-heading">
              <ul>
  <li>
    <a href="#spruce">Spruce</a>
    <ul>
      <li>
        <a href="#installation">Installation</a>
      </li>
      <li>
        <a href="#default-merge-with-simple-keys">Default merge with simple keys</a>
      </li>
      <li>
        <a href="#default-merge-with-maps">Default merge with maps</a>
      </li>
      <li>
        <a href="#reference-other-data">Reference other data</a>
      </li>
      <li>
        <a href="#pruning">Pruning</a>
      </li>
      <li>
        <a href="#arrays">Arrays</a>
        <ul>
          <li>
            <a href="#default-inline-replace-with-simple-keys">Default inline replace with simple keys</a>
          </li>
          <li>
            <a href="#default-inline-replace-with-maps">Default inline replace with maps</a>
          </li>
          <li>
            <a href="#inline">Inline</a>
          </li>
          <li>
            <a href="#append">Append</a>
          </li>
          <li>
            <a href="#prepend">Prepend</a>
          </li>
          <li>
            <a href="#replace">Replace</a>
          </li>
          <li>
            <a href="#merge-list-of-maps">Merge list of maps</a>
          </li>
        </ul>
      </li>
      <li>
        <a href="#static-ips">Static IPs</a>
      </li>
      <li>
        <a href="#concatenate-strings">Concatenate strings</a>
      </li>
      <li>
        <a href="#replace-maps">Replace maps</a>
      </li>
      <li>
        <a href="#inject-subtree">Inject subtree</a>
      </li>
      <li>
        <a href="#prevent-null-values">Prevent null values</a>
      </li>
      <li>
        <a href="#or-operator">OR operator</a>
      </li>
    </ul>
  </li>
</ul>

            </nav>
          </div>
        </div>

        <div class="app-pane__content toc-open-disabled">
          <main id="content" class="technical-documentation" data-module="anchored-headings">
            <h1 id="spruce">Spruce</h1>
<p>This is a guide to <a href="https://github.com/geofffranks/spruce">spruce</a>, our tool to merge YAML manifests. It contains very simple examples to explain each feature.</p>

<p>For more information, see the spruce readme and <a href="https://github.com/geofffranks/spruce/tree/master/examples">examples</a>.</p>
<h2 id="installation">Installation</h2>
<p>You need to install spruce &gt;= 0.13.0. This version added support for operand expressions.</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ go get github.com/geofffranks/spruce/cmd/spruce # Builds spruce, including dependencies and puts it in $GOPATH/bin
</code></pre></div>
<p>To upgrade spruce:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ go get -u github.com/geofffranks/spruce/cmd/spruce
</code></pre></div>
<p>Note: If you previously built spruce from a branch, following instructions in a
previous version of this guide, you may need to find and remove old
copies of the <code>spruce</code> binary that were copied into your $PATH:</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ spruce -v     # if version 0.12.0 is reported, you probably built from the branch
$ which spruce  # shows files you may need to remove
</code></pre></div><h2 id="default-merge-with-simple-keys">Default merge with simple keys</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
a: aaaa
a2: aaaa
$ cat b.yml
a: bbbb
b: bbbb
$ spruce merge a.yml b.yml
a: bbbb
a2: aaaa
b: bbbb
$ spruce merge b.yml a.yml
a: aaaa
a2: aaaa
b: bbbb

</code></pre></div>
<ul>
<li>Files to merge are listed in-order on the command line. The first file serves as the base to the file structure, and subsequent files are merged on top, adding when keys are new, replacing when keys exist</li>
<li>A key in the subsequent file overrides the key at the same place. No need for <code>(( merge ))</code> for simple values</li>
</ul>
<h2 id="default-merge-with-maps">Default merge with maps</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key:
  subkey1: aa1
  subkey2: aa2
  subkey3: aa3
$ cat b.yml
key:
  subkey1: bb1
  subkey2: bb2
  subkey4: bb4
$ spruce merge a.yml b.yml
key:
  subkey1: bb1
  subkey2: bb2
  subkey3: aa3
  subkey4: bb4
</code></pre></div>
<ul>
<li>Same keys are updated</li>
<li>Additional keys are added</li>
<li>Keys not present in other files are kept</li>
</ul>
<h2 id="reference-other-data">Reference other data</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key:
  subkey1: aa1
  subkey2: aa2
a: (( grab key.subkey1 ))
$ cat b.yml
key:
  subkey1: bb1
  subkey2: bb2
$ spruce merge a.yml b.yml
a: bb1
key:
  subkey1: bb1
  subkey2: bb2
</code></pre></div>
<ul>
<li><code>grab</code> allows to merge with the value of another key</li>
<li>The merge happens first: here <code>key.subkey1</code> changes from <code>aa</code> to <code>bb1</code>. Then the <code>grab</code> happens: <code>a:</code> takes the new <code>key.subkey1</code> value <code>bb1</code></li>
</ul>
<div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key:
  subkey1: aa1
  subkey2: aa2
a: (( grab key.subkey1 key.subkey2 key ))
$ cat b.yml
key:
  subkey1: bb1
  subkey2: bb2
$ spruce merge a.yml b.yml
a:
- bb1
- bb2
- subkey1: bb1
  subkey2: bb2
key:
  subkey1: bb1
  subkey2: bb2
</code></pre></div>
<ul>
<li>When given several values, <code>grab</code> will create an array</li>
<li>Values can be simple keys or more complex like maps</li>
<li>Can be separated with commas or spaces</li>
</ul>
<h2 id="pruning">Pruning</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key:
  subkey1: aa
  subkey2: aa
a:
- name: a1
  a11: a11
  a12: a12
- name: a2
  a11: a21
  a12: a22
$ cat b.yml
key:
  subkey1: bb
  subkey2: bb
a:
- name: a1
  a11: b11
$ spruce merge --prune a.a1.a11 --prune key.subkey1 a.yml b.yml
a:
- a12: a12
  name: a1
- a11: a21
  a12: a22
  name: a2
key:
  subkey2: bb
</code></pre></div>
<ul>
<li>Prunes keys based on the path</li>
<li>To reference a key in an array of maps, use <code>name:</code> as identifer</li>
<li>This can be useful to delete temporary keys, ones that we use only to generate values for other keys but we don&rsquo;t need in the final output</li>
</ul>
<h2 id="arrays">Arrays</h2><h3 id="default-inline-replace-with-simple-keys">Default inline replace with simple keys</h3><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
a:
- a1
- a2
- a3
$ cat b.yml
a:
- b1
- b2
$ spruce merge a.yml b.yml
a:
- b1
- b2
- a3

</code></pre></div>
<ul>
<li>This replaces key by key in the order of the array</li>
</ul>
<h3 id="default-inline-replace-with-maps">Default inline replace with maps</h3><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
a:
- name123: a1
  a11: a11
  a12: a12
- name123: a2
  a11: a21
  a12: a22
$ cat b.yml
a:
- name123: a1
  a11: b11
$ spruce merge a.yml b.yml
a:
- a11: b11
  a12: a12
  name123: a1
- a11: a21
  a12: a22
  name123: a2
</code></pre></div>
<ul>
<li>This works for an array of maps. It updates the keys in the maps following the order of the array</li>
</ul>
<h3 id="inline">Inline</h3>
<p>Same as <em>Simple replacement</em>, using <code>- (( inline ))</code> as first element. Maybe more explicit.</p>
<h3 id="append">Append</h3><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
a:
- a1
- a2
- a3
$ cat b.yml
a:
- (( append ))
- b1
- b2
- b3
- b4
</code></pre></div>
<ul>
<li>The merge behaviour is specified in the <em>next</em> file, which is different than spiff</li>
<li><code>(( append ))</code> must be the first element</li>
</ul>
<h3 id="prepend">Prepend</h3>
<p>Prepend keys. Usage: same with <code>- (( prepend ))</code> instead</p>
<h3 id="replace">Replace</h3>
<p>Replaces the whole array. Usage: same with <code>- (( replace ))</code> instead</p>
<h3 id="merge-list-of-maps">Merge list of maps</h3><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
a:
- name: a1
  a11: a11
  a12: a12
- name: a2
  a11: a21
  a12: a22
$ cat b.yml
a:
- (( merge ))
- name: a1
  a11: b11
$ spruce merge a.yml b.yml
a:
- a11: b11
  a12: a12
  name: a1
- a11: a21
  a12: a22
  name: a2
</code></pre></div>
<ul>
<li>This merges a list of maps based on key &ldquo;name&rdquo; as identifier</li>
<li>This allows to override only a set of keys in an array of maps</li>
<li>To merge based on another key, use <code>(( merge on &lt;key&gt; ))</code></li>
</ul>
<h2 id="static-ips">Static IPs</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat networks.yml
networks:
- name: net1
  subnets:
  - cloud_properties: random
    static:
    - 192.168.0.2 - 192.168.0.10
$ cat jobs.yml
jobs:
- name: staticIP_z1
  instances: 3
  networks:
  - name: net1
    static_ips: (( static_ips(0, 2, 4) ))
- name: api_z1
  instances: 3
  networks:
  - name: net1
    static_ips: (( static_ips(1, 3, 5) ))
$ cat properties.yml
properties:
  staticIP_servers: (( grab jobs.staticIP_z1.networks.net1.static_ips ))
  api_servers: (( grab jobs.api_z1.networks.net1.static_ips ))
</code></pre></div>
<ul>
<li><code>static_ips()</code> functions works similarly to <code>spiff</code></li>
<li>It selects a list of IPs from a particular network in <code>networks:</code> map</li>
<li>It creates as many IPs as jobs instances</li>
<li>It checks for conflicts</li>
<li>merge runs first, then <code>static_ips()</code>, then finally <code>grab</code>. So the order of the manifests in the merge command doesn&rsquo;t matter for this particular case.</li>
</ul>
<h2 id="concatenate-strings">Concatenate strings</h2><div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key:
  subkey1: aa1
  subkey2: aa2
other_key: aaaa
a: (( concat "subkey1=" key.subkey1 " and other_key=" other_key ))
$ cat b.yml
key:
  subkey1: bb1
  subkey2: bb2
$ spruce merge a.yml b.yml
a: subkey1=bb1 and other_key=aaaa
key:
  subkey1: bb1
  subkey2: bb2
other_key: aaaa
</code></pre></div>
<ul>
<li>We can concatenate a list of strings</li>
<li>Strings can be quoted string literals, keys from the same file or keys resulting from merge</li>
<li>Merge happens first, then <code>concat</code></li>
<li>Can be separated with commas or spaces</li>
</ul>
<h2 id="replace-maps">Replace maps</h2>
<p>The default in spruce is to merge maps, whereas spiff was replacing. To replace with spruce, we need 2 steps instead of 1:</p>

<ul>
<li>delete the map</li>
<li>add the new map</li>
</ul>

<p>See https://github.com/geofffranks/spruce#map-replacement</p>
<h2 id="inject-subtree">Inject subtree</h2>
<p>YAML has the concept of anchor/alias to inject another subtree from the same file. See: https://en.wikipedia.org/wiki/YAML#Repeated_nodes</p>

<p>In spruce the same can be achieved <em>across different files</em>.</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
green:
  woot: (( inject meta.template ))
  color: green
$ cat b.yml
meta:
  template:
    color: blue
    size: small
$ spruce merge a.yml b.yml
green:
  color: green
  size: small
meta:
  template:
    color: blue
    size: small
</code></pre></div><h2 id="prevent-null-values">Prevent <em>null</em> values</h2>
<p>We can add useful error checking to prevent null values due to merge errors. This is probably a good practice to use in any key where we expect a value from a merge.</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
critical_key:
$ spruce merge a.yml
critical_key: null
$ cat a.yml
critical_key: (( param "Merge error! critical_key can't be null."))
$ spruce merge a.yml
1 error(s) detected:
 - $.critical_key: Merge error! critical_key can't be null.
$ echo $?
2
$ cat b.yml
critical_key: critical_value
$ spruce merge a.yml b.yml
critical_key: critical_value
</code></pre></div><h2 id="or-operator"><em>OR</em> operator</h2>
<p>Alows to specify alternate values in the first key is null. Compatible with <code>grab</code> and <code>concat</code>.</p>
<div class="highlight"><pre class="highlight plaintext"><code>$ cat a.yml
key1:
    subkey1: a1
    subkey2: a2
# String literal
key2: (( grab absent_key || "default value" ))
# Other key
key3: (( grab absent_key || key1.subkey1 ))
# null (can enter nil, null, Null, and so on)
key4: (( grab absent_key || Null ))
# Boolean
key5: (( grab absent_key || false ))
# Chaining
key6: (( grab absent_key || key1.absent_key || "other default" ))
# Concatenate strings
key7: (( concat "beginning_" absent_key || key1.subkey1 ))
# Grab
key8: (( grab absent_key || key1.subkey1, key1.subkey2 ))
# Multiple keys in concat
key9: (( concat "beginning_", absent_key || key1.subkey1, "_middle_", key1.absent_key || key1.subkey2 ))
$ cat b.yml
key1:
    subkey1: b1
    subkey2: b2
$ spruce merge a.yml b.yml
key1:
  subkey1: b1
  subkey2: b2
key2: default value
key3: b1
key4: null
key5: false
key6: other default
key7: beginning_b1
key8:
- b1
- b2
key9: beginning_b1_middle_b2
</code></pre></div>
          </main>

          <footer class="footer">
  <div class="footer__licence">
    <a class="footer__licence-logo" href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" rel="license">Open Government Licence</a>
    <p class="footer__licence-description">All content is available under the <a href="https://www.nationalarchives.gov.uk/doc/open-government-licence/version/3/" rel="license">Open Government Licence v3.0</a>, except where otherwise stated</p>
  </div>

  <div class="footer__copyright">
    <a class="footer__copyright-logo" href="http://www.nationalarchives.gov.uk/information-management/re-using-public-sector-information/copyright-and-re-use/crown-copyright/">© Crown copyright</a>
  </div>
</footer>

        </div>
      </div>
    </div>

    
  </body>
</html>
